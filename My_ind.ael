defun draw_inductor_multi_ring(centerX, centerY, Nturns, spacing, lengthX, lengthY, cornerK, pathWidth, wireLayerName, underLayerName, viaLayerName, terminalmode, terminalWidth, terminalLength, terminalGap)
{    
    //选择并清除
    de_select_all();
    de_delete();

    draw_octagon_Nturns_inner_XY(centerX, centerY, Nturns, spacing, lengthX, lengthY, cornerK, pathWidth, wireLayerName);

    
    //选择全部
    de_select_all();

    decl lengthY_chop = lengthY + (Nturns - 1) * (spacing + pathWidth) * 2.0 + pathWidth;
    decl lengthX_chop = spacing + 2 * pathWidth;
    
    // 使用de_chop创建中空区域（考虑中心点偏移）
    de_chop(centerX - lengthX_chop/2.0, centerY - lengthY_chop/2.0 + pathWidth,  // 内部区域左下角
            centerX + lengthX_chop/2.0, centerY + lengthY_chop/2.0);  // 内部区域右上角

    // 绘制交叉结构 上半部分
    draw_intersection_Nturns_upper(centerX, centerY + lengthY/2.0, Nturns, spacing, pathWidth, wireLayerName, underLayerName, viaLayerName);

    // 绘制交叉结构 下半部分
    draw_intersection_Nturns_lower(centerX, centerY - lengthY/2.0, Nturns, spacing, pathWidth, wireLayerName, underLayerName, viaLayerName);

    // 绘制终端
    decl length = spacing + pathWidth;
    decl new_centerY = centerY - ((Nturns - 1) * length + lengthY/2.0);
    if (terminalmode == 1)
    {

        draw_terminal(centerX, new_centerY, terminalWidth, pathWidth, terminalLength, terminalGap, wireLayerName);
    }

    else
    {
        draw_terminal(centerX, new_centerY, pathWidth, pathWidth, terminalLength, length, wireLayerName);
    }


}



